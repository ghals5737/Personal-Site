---
title: "Complete Docker Deployment Guide for Next.js Applications"
description: "Learn how to deploy your Next.js application using Docker, docker-compose, and Nginx with best practices for production environments"
date: "2024-01-20"
published: true
tags: ["Docker", "Next.js", "DevOps", "Deployment", "Nginx"]
category: "DevOps"
author: "Your Name"
image: "/images/blog/docker-deployment.jpg"
---

# Complete Docker Deployment Guide for Next.js Applications

Deploying Next.js applications with Docker provides consistency, scalability, and ease of management. This comprehensive guide covers everything from basic containerization to production-ready deployment with Nginx.

## Why Docker for Next.js?

Docker offers several advantages for Next.js deployments:

- **Consistency**: Same environment across development, staging, and production
- **Isolation**: Dependencies don't conflict with the host system
- **Scalability**: Easy horizontal scaling with orchestration tools
- **Portability**: Deploy anywhere Docker runs

## Multi-stage Dockerfile

Here's an optimized multi-stage Dockerfile for Next.js:

```dockerfile
# Base image with Node.js
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

# Install dependencies
COPY package.json package-lock.json* ./
RUN npm ci --only=production

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Build the application
RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# Set the correct permission for prerender cache
RUN mkdir .next
RUN chown nextjs:nodejs .next

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

CMD ["node", "server.js"]
```

## Docker Compose Configuration

Create a `docker-compose.yml` for easy management:

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - SITE_URL=https://mydomain.tld
    volumes:
      - ./public/uploads:/app/public/uploads
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped
```

## Nginx Configuration

Optimized Nginx configuration for Next.js:

```nginx
events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # Logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log warn;

    # Performance optimizations
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;

    upstream nextjs_upstream {
        server app:3000;
    }

    server {
        listen 80;
        server_name mydomain.tld www.mydomain.tld;
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name mydomain.tld www.mydomain.tld;

        # SSL configuration
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
        ssl_prefer_server_ciphers off;

        # Static files caching
        location /_next/static/ {
            proxy_pass http://nextjs_upstream;
            proxy_cache_valid 200 1y;
            add_header Cache-Control "public, immutable";
        }

        # API rate limiting
        location /api/ {
            limit_req zone=api burst=20 nodelay;
            proxy_pass http://nextjs_upstream;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # All other requests
        location / {
            proxy_pass http://nextjs_upstream;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

## Deployment Script

Create a deployment script for automation:

```bash
#!/bin/bash
set -e

echo "üöÄ Starting deployment..."

# Pull latest changes
git pull origin main

# Build and start services
docker-compose down
docker-compose build --no-cache
docker-compose up -d

# Wait for services to be healthy
echo "‚è≥ Waiting for services to start..."
sleep 30

# Check health
if curl -f http://localhost:3000/api/health; then
    echo "‚úÖ Deployment successful!"
else
    echo "‚ùå Deployment failed!"
    exit 1
fi

# Clean up old images
docker image prune -f

echo "üéâ Deployment completed!"
```

## Health Check Endpoint

Add a health check to your Next.js API:

```typescript
// pages/api/health.ts
import { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'GET') {
    res.status(200).json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
    })
  } else {
    res.setHeader('Allow', ['GET'])
    res.status(405).end(`Method ${req.method} Not Allowed`)
  }
}
```

## Best Practices

### Security
- Use non-root user in containers
- Keep base images updated
- Scan images for vulnerabilities
- Use secrets management for sensitive data

### Performance
- Enable Next.js standalone output
- Use multi-stage builds to reduce image size
- Implement proper caching strategies
- Monitor resource usage

### Monitoring
- Set up health checks
- Use structured logging
- Monitor application metrics
- Set up alerts for failures

## Conclusion

This deployment setup provides a solid foundation for production Next.js applications. The combination of Docker, docker-compose, and Nginx offers excellent performance, security, and maintainability.

Remember to:
- Test thoroughly in staging environments
- Monitor your application after deployment
- Keep your dependencies updated
- Document your deployment process

Happy deploying! üöÄ
